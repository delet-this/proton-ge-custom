diff --git c/akibauu_bytestream_read_hack.patch i/akibauu_bytestream_read_hack.patch
new file mode 100644
index 00000000000..e69de29bb2d
diff --git c/dlls/mfplat/main.c i/dlls/mfplat/main.c
index 0a7c294294e..5b6550f969b 100644
--- c/dlls/mfplat/main.c
+++ i/dlls/mfplat/main.c
@@ -56,6 +56,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+#include "imfbytestream_read_hack.h"
+
 struct local_handler
 {
     struct list entry;
@@ -6266,7 +6268,7 @@ static HRESULT resolver_get_bytestream_url_hint(IMFByteStream *stream, WCHAR con
         return hr;
     if (position && FAILED(hr = IMFByteStream_SetCurrentPosition(stream, 0)))
         return hr;
-    if (FAILED(hr = IMFByteStream_Read(stream, buffer, sizeof(buffer), &length)))
+    if (FAILED(hr = IMFByteStream_Read_Hack(stream, buffer, sizeof(buffer), &length)))
         return hr;
 
     if (length < sizeof(buffer))
diff --git c/dlls/mfsrcsnk/media_source.c i/dlls/mfsrcsnk/media_source.c
index c055f10ccf8..a0246320393 100644
--- c/dlls/mfsrcsnk/media_source.c
+++ i/dlls/mfsrcsnk/media_source.c
@@ -26,6 +26,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+#include "imfbytestream_read_hack.h"
+
 #define DEFINE_MF_ASYNC_CALLBACK_(type, name, impl_from, pfx, mem, expr)                           \
     static struct type *impl_from(IMFAsyncCallback *iface)                                         \
     {                                                                                              \
@@ -1658,7 +1660,7 @@ static NTSTATUS CDECL media_source_read_cb(struct winedmo_stream *stream, BYTE *
     struct media_source *source = CONTAINING_RECORD(stream, struct media_source, winedmo_stream);
     TRACE("stream %p, buffer %p, size %p\n", stream, buffer, size);
 
-    if (FAILED(IMFByteStream_Read(source->stream, buffer, *size, size)))
+    if (FAILED(IMFByteStream_Read_Hack(source->stream, buffer, *size, size)))
         return STATUS_UNSUCCESSFUL;
     return STATUS_SUCCESS;
 }
diff --git c/dlls/winegstreamer/media_source.c i/dlls/winegstreamer/media_source.c
index 284cf310219..7d985794bc2 100644
--- c/dlls/winegstreamer/media_source.c
+++ i/dlls/winegstreamer/media_source.c
@@ -27,6 +27,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+#include "imfbytestream_read_hack.h"
+
 struct object_context
 {
     IUnknown IUnknown_iface;
@@ -924,7 +926,7 @@ static DWORD CALLBACK read_thread(void *arg)
         ret_size = 0;
 
         if (SUCCEEDED(hr = IMFByteStream_SetCurrentPosition(byte_stream, offset)))
-            hr = IMFByteStream_Read(byte_stream, data, size, &ret_size);
+            hr = IMFByteStream_Read_Hack(byte_stream, data, size, &ret_size);
         if (FAILED(hr))
             ERR("Failed to read %u bytes at offset %I64u, hr %#lx.\n", size, offset, hr);
         else if (ret_size != size)
diff --git c/include/Makefile.in i/include/Makefile.in
index 4db5c9dc1a8..c4299946723 100644
--- c/include/Makefile.in
+++ i/include/Makefile.in
@@ -374,6 +374,7 @@ SOURCES = \
 	iimgctx.idl \
 	imagehlp.h \
 	ime.h \
+	imfbytestream_read_hack.h \
 	imm.h \
 	immdev.h \
 	imnact.idl \
diff --git c/include/imfbytestream_read_hack.h i/include/imfbytestream_read_hack.h
new file mode 100644
index 00000000000..ec468f97a54
--- /dev/null
+++ i/include/imfbytestream_read_hack.h
@@ -0,0 +1,158 @@
+#ifndef READ_HACK_INCLUDED
+#define READ_HACK_INCLUDED
+
+#include "mfobjects.h"
+#include "winternl.h"
+
+struct read_hack_callback
+{
+    IMFAsyncCallback IMFAsyncCallback_iface;
+    LONG refcount;
+    HANDLE event;
+    DWORD param;
+    IMFMediaEvent *media_event;
+    IMFAsyncResult *result;
+};
+
+static struct read_hack_callback *read_hack_callback_from_IMFAsyncCallback(IMFAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct read_hack_callback, IMFAsyncCallback_iface);
+}
+
+static HRESULT WINAPI read_hack_callback_QueryInterface(IMFAsyncCallback *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IMFAsyncCallback) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFAsyncCallback_AddRef(iface);
+        return S_OK;
+    }
+
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI read_hack_callback_AddRef(IMFAsyncCallback *iface)
+{
+    struct read_hack_callback *callback;
+
+    callback = read_hack_callback_from_IMFAsyncCallback(iface);
+    return InterlockedIncrement(&callback->refcount);
+}
+
+static ULONG WINAPI read_hack_callback_Release(IMFAsyncCallback *iface)
+{
+    struct read_hack_callback *callback;
+    ULONG refcount;
+
+    callback = read_hack_callback_from_IMFAsyncCallback(iface);
+    refcount = InterlockedDecrement(&callback->refcount);
+
+    if (!refcount)
+    {
+        CloseHandle(callback->event);
+        free(callback);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI read_hack_callback_GetParameters(IMFAsyncCallback *iface, DWORD *flags, DWORD *queue)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI read_hack_async_callback_result_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
+{
+    struct read_hack_callback *callback;
+
+    callback = read_hack_callback_from_IMFAsyncCallback(iface);
+
+    callback->result = result;
+    IMFAsyncResult_AddRef(callback->result);
+    SetEvent(callback->event);
+
+    return S_OK;
+}
+
+static const IMFAsyncCallbackVtbl read_hack_async_callback_result_vtbl =
+{
+    read_hack_callback_QueryInterface,
+    read_hack_callback_AddRef,
+    read_hack_callback_Release,
+    read_hack_callback_GetParameters,
+    read_hack_async_callback_result_Invoke,
+};
+
+static struct read_hack_callback * create_read_hack_callback(const IMFAsyncCallbackVtbl *vtbl)
+{
+    struct read_hack_callback *callback;
+
+    callback = calloc(1, sizeof(*callback));
+
+    callback->IMFAsyncCallback_iface.lpVtbl = vtbl;
+    callback->refcount = 1;
+    callback->event = CreateEventA(NULL, FALSE, FALSE, NULL);
+
+    return callback;
+}
+
+static inline HRESULT IMFByteStream_Read_Hack(IMFByteStream *stream, BYTE *pb, ULONG cb, ULONG *pcbRead) {
+    /* HACK: Use the async BeginRead/EndRead interface due to buggy 
+     * sync Read implementation on the game's end. */
+    static int cached = -1;
+    HRESULT hr;
+
+    if (cached == -1)
+    {
+        const char *sgi;
+        WARN("HACK: Enabled using async BeginRead instead of sync Read.\n");
+        sgi = getenv("SteamGameId");
+        cached = !strcmp(sgi, "333980");
+    }
+
+    hr = IMFByteStream_Read(stream, pb, cb, pcbRead);
+
+    if (cached && *pcbRead == 0xffffffff)
+    {
+        DWORD res;
+        IMFAsyncResult *result = NULL;
+        struct read_hack_callback *read_callback;
+
+        TRACE("HACK: Using async BeginRead instead of sync Read.\n");
+
+        read_callback = create_read_hack_callback(&read_hack_async_callback_result_vtbl);
+
+        if (FAILED(hr = IMFByteStream_BeginRead(stream, pb, cb, &read_callback->IMFAsyncCallback_iface, NULL)))
+        {
+            WARN("BeginRead failed with %#lx, falling back to Read.\n", hr);
+            hr = IMFByteStream_Read(stream, pb, cb, pcbRead);
+            goto end;
+        }
+
+        if ((res = WaitForSingleObject(read_callback->event, 100)) != WAIT_OBJECT_0)
+        {
+            ERR("Waiting for BeginRead result failed with %#lx.\n", res);
+            hr = E_INVALIDARG;
+            goto end;
+        }
+
+        result = read_callback->result;
+        read_callback->result = NULL;
+
+        if (FAILED(hr = IMFByteStream_EndRead(stream, result, pcbRead)))
+        {
+            WARN("EndRead failed with %#lx.\n", hr);
+        }
+
+end:
+        if (result)
+            IMFAsyncResult_Release(result);
+        IMFAsyncCallback_Release(&read_callback->IMFAsyncCallback_iface);
+    }
+
+    return hr;
+}
+
+#endif /* READ_HACK_INCLUDED */
